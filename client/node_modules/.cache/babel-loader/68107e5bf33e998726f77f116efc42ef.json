{"ast":null,"code":"import _regeneratorRuntime from \"C:\\\\Users\\\\benja\\\\OneDrive\\\\Desktop\\\\Code\\\\project3\\\\calendule\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _slicedToArray from \"C:\\\\Users\\\\benja\\\\OneDrive\\\\Desktop\\\\Code\\\\project3\\\\calendule\\\\client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n\nimport toMomentLocale from \"./toMomentLocale\";\nimport { DEFAULT_FALLBACK_LOCALE } from \"../res/locales\";\n/**\n * Imports a Moment locale asynchronously (using dynamic imports).\n *\n * @param {string|*} locale The locale to import. A value which is not a string may be passed and it will be normalized to an empty string\n *                          which will be treated as an unknown locale resolving to the Moment's default locale (USA's English, i.e. \"en\").\n * @param {(normalizedLocale: string, locale: string|*) => *} [unknownLocaleCallback] A callback called with the Moment's default locale (USA's English, i.e. \"en\")\n *                                                                                    if the given locale is unknown as its first parameter and the given unknown locale\n *                                                                                    as its second parameter.\n *                                                                                    This callback will be called only when the given locale is not a locale\n *                                                                                    known to Moment and it's not the Moment's default locale (USA's English, i.e. \"en\").\n *                                                                                    If a locale is unknown, the callback is called before resolving\n *                                                                                    the returned promise and the promise will resolve with the Moment's default locale\n *                                                                                    (USA's English, i.e. \"en\").\n * @return {Promise} A promise which, if fulfilled, resolves with the normalized locale when the given locale has been imported\n *                   successfully or rejects with an error if the given locale cannot be imported\n *                   (e.g. the locale chunk filename is not found or there is a network error).\n *                   If the locale is unknown, then the returned promise doesn't reject.\n */\n\nexport default function importLocale(_x) {\n  return _importLocale.apply(this, arguments);\n}\n\nfunction _importLocale() {\n  _importLocale = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(locale) {\n    var unknownLocaleCallback,\n        _toMomentLocale,\n        _toMomentLocale2,\n        normalizedLocale,\n        isKnown,\n        promise,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            unknownLocaleCallback = _args.length > 1 && _args[1] !== undefined ? _args[1] : void 0;\n            _toMomentLocale = toMomentLocale(locale), _toMomentLocale2 = _slicedToArray(_toMomentLocale, 2), normalizedLocale = _toMomentLocale2[0], isKnown = _toMomentLocale2[1];\n            promise = Promise.resolve();\n\n            if (isKnown) {\n              if (normalizedLocale !== DEFAULT_FALLBACK_LOCALE) {\n                promise = import(\"moment/locale/\".concat(normalizedLocale));\n              } else {// Moment does not bundle its default locale in a separate file,\n                // so there's nothing to do here.\n              }\n            } else {\n              typeof unknownLocaleCallback === \"function\" && unknownLocaleCallback(normalizedLocale, locale);\n            }\n\n            _context.next = 6;\n            return promise;\n\n          case 6:\n            return _context.abrupt(\"return\", normalizedLocale);\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _importLocale.apply(this, arguments);\n}","map":{"version":3,"sources":["../src/importLocale.js"],"names":["unknownLocaleCallback","toMomentLocale","promise","Promise","normalizedLocale"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,OAAA,cAAA,MAAA,kBAAA;AACA,SAAA,uBAAA,QAAA,gBAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAA,SAAA,YAAA,CAAA,EAAA,EAAA;AAAA,SAAA,aAAA,CAAA,KAAA,CAAA,IAAA,EAAA,SAAA,CAAA;AAAA;;;2EAAe,iBAAA,MAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAEbA,YAAAA,qBAFa,2DAEW,KAFX,CAAA;AAAA,8BAIuBC,cAAc,CAAlD,MAAkD,CAJrC,yDAIP,gBAJO,wBAIP,OAJO;AAKTC,YAAAA,OALS,GAKCC,OAAO,CAArB,OAAcA,EALD;;AAMb,gBAAA,OAAA,EAAa;AACX,kBAAIC,gBAAgB,KAApB,uBAAA,EAAkD;AAChDF,gBAAAA,OAAO,GAAG,+BAAVA,gBAAU,EAAVA;AADF,eAAA,MAEO,CACL;AACA;AACD;AANH,aAAA,MAOO;AACL,qBAAA,qBAAA,KAAA,UAAA,IACEF,qBAAqB,CAAA,gBAAA,EADvB,MACuB,CADvB;AAED;;AAhBY;AAiBb,mBAAA,OAAA;;AAjBa;AAAA,6CAkBb,gBAlBa;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["/*\n * Copyright (c) 2020 Anton Bagdatyev (Tonix)\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\nimport toMomentLocale from \"./toMomentLocale\";\nimport { DEFAULT_FALLBACK_LOCALE } from \"../res/locales\";\n\n/**\n * Imports a Moment locale asynchronously (using dynamic imports).\n *\n * @param {string|*} locale The locale to import. A value which is not a string may be passed and it will be normalized to an empty string\n *                          which will be treated as an unknown locale resolving to the Moment's default locale (USA's English, i.e. \"en\").\n * @param {(normalizedLocale: string, locale: string|*) => *} [unknownLocaleCallback] A callback called with the Moment's default locale (USA's English, i.e. \"en\")\n *                                                                                    if the given locale is unknown as its first parameter and the given unknown locale\n *                                                                                    as its second parameter.\n *                                                                                    This callback will be called only when the given locale is not a locale\n *                                                                                    known to Moment and it's not the Moment's default locale (USA's English, i.e. \"en\").\n *                                                                                    If a locale is unknown, the callback is called before resolving\n *                                                                                    the returned promise and the promise will resolve with the Moment's default locale\n *                                                                                    (USA's English, i.e. \"en\").\n * @return {Promise} A promise which, if fulfilled, resolves with the normalized locale when the given locale has been imported\n *                   successfully or rejects with an error if the given locale cannot be imported\n *                   (e.g. the locale chunk filename is not found or there is a network error).\n *                   If the locale is unknown, then the returned promise doesn't reject.\n */\nexport default async function importLocale(\n  locale,\n  unknownLocaleCallback = void 0\n) {\n  const [normalizedLocale, isKnown] = toMomentLocale(locale);\n  let promise = Promise.resolve();\n  if (isKnown) {\n    if (normalizedLocale !== DEFAULT_FALLBACK_LOCALE) {\n      promise = import(`moment/locale/${normalizedLocale}`);\n    } else {\n      // Moment does not bundle its default locale in a separate file,\n      // so there's nothing to do here.\n    }\n  } else {\n    typeof unknownLocaleCallback === \"function\" &&\n      unknownLocaleCallback(normalizedLocale, locale);\n  }\n  await promise;\n  return normalizedLocale;\n}\n"]},"metadata":{},"sourceType":"module"}